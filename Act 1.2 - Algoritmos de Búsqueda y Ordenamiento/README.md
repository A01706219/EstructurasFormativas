Tarea 2.1

#Ordenamiento Selección

Análisis de complejidad temporal

El código tiene una complejidad de O(n^2) en el peor de los casos ya que tiene dos ciclos for en los que uno recorre todo el arreglo y el otro que
checa cada uno valor y los va intercambiando con el swap().

#Ordenamiento burbuja

Análisis de complejidad temporal

El código tiene una complejidad de O(n^2) en el peor de los casos ya que tiene dos ciclos for, uno que va del último valor del arreglo hasta el primero
y otro for que va de izquierda a derecha checando estos valores.

#Ordenamiento Merge

Análisis de complejidad temporal

En el peor de los casos tendríamos una complejidad de O(n log(n)) ya que este codigo es muy rapido al dividir el arreglo a la mitad y despues comparar por 
pequeños grupos. Es muy eficiente y rápido pero el problema es que usa mucha memoria ya que el árbol puede crecer mucho.

#Busqueda Secuencial

Análisis de complejidad temporal

La busqueda secuencial tiene una complejidad lineal de O(n) ya que unicamente recorre el arreglo hasta el valor proporcionado.

#Busqueda Binaria

Análisis de complejidad temporal

La busqueda binaria es O(log (n)) ya que el arreglo se va partiendo hasta encontrar el valor ya sea que se encuentre arriba de la mitad o abajo.
